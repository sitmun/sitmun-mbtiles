package org.sitmun.mbtiles.process;

import ch.poole.geo.mbtiles4j.MBTilesWriteException;
import ch.poole.geo.mbtiles4j.Tile;
import ch.poole.geo.mbtiles4j.model.MetadataBounds;
import ch.poole.geo.mbtiles4j.model.MetadataEntry;
import java.awt.image.BufferedImage;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.BiConsumer;
import javax.imageio.ImageIO;
import lombok.extern.slf4j.Slf4j;
import org.sitmun.mbtiles.Constants;
import org.sitmun.mbtiles.dto.TileServiceDto;
import org.sitmun.mbtiles.jobs.TaskContext;
import org.sitmun.mbtiles.service.MBTilesProgressService;
import org.sitmun.mbtiles.wmts.*;
import org.springframework.batch.core.scope.context.StepContext;
import org.springframework.stereotype.Component;

@Component
@Slf4j
public class WMTSHarvestProcess implements BiConsumer<StepContext, TaskContext> {

  private final MBTilesProgressService mbTilesProgressService;

  public WMTSHarvestProcess(MBTilesProgressService mbTilesProgressService) {
    this.mbTilesProgressService = mbTilesProgressService;
  }

  @Override
  public void accept(StepContext stepContext, TaskContext mbtilesContext) {
    try {
      TileServiceDto service = mbtilesContext.getService();
      String outputPath = mbtilesContext.getOutputPath();
      Capabilities capabilities = CapabilitiesUtils.parseWMTSCapabilities(service);
      File outputFile = new File(outputPath);
      CustomMBTilesWriter writer = new CustomMBTilesWriter(outputFile);
      CustomMBTilesReader reader = new CustomMBTilesReader(outputFile);
      double[] bounds = {
        service.getMinLon(), service.getMinLat(), service.getMaxLon(), service.getMaxLat()
      };

      if (!service.getSrs().equals(Constants.MB_TILES_SRS)) {
        bounds = Proj4Utils.transformExtent(bounds, service.getSrs(), Constants.MB_TILES_SRS);
      }
      long procesados = 0;
      long total = 0;
      Map<LayerCapabilities, List<TileCoordinate>> layersCoordinates = new HashMap<>();
      for (LayerCapabilities lc : capabilities.getLayers()) {
        List<TileCoordinate> coordinates =
            CoordinatesUtils.calculateCoordinates(service, lc, bounds);
        layersCoordinates.put(lc, coordinates);
        total += coordinates.size();
      }
      long jobId = stepContext.getJobInstanceId();
      mbTilesProgressService.updateJobProgress(jobId, total, procesados);
      for (Map.Entry<LayerCapabilities, List<TileCoordinate>> entry :
          layersCoordinates.entrySet()) {
        LayerCapabilities lc = entry.getKey();
        List<TileCoordinate> coordinates = entry.getValue();
        for (TileCoordinate coord : coordinates) {
          // Check if the job has been stopped by checking the step execution status
          if (stepContext.getStepExecution().getStatus().isUnsuccessful()
              || stepContext.getStepExecution().getJobExecution().getStatus().isUnsuccessful()) {
            log.info("Job {} has been stopped, exiting tile processing", jobId);
            return;
          }

          BufferedImage tile = getTileImage(service, lc.getLayerIdentifier(), coord);

          if (tile != null) {
            addOrUpdateTitle(coord, reader, tile, writer);
          }
          procesados++;

          // Check for stop signals more frequently (every 10 tiles instead of 50)
          if (procesados % 10 == 0) {
            mbTilesProgressService.updateJobProgress(jobId, total, procesados);

            // Additional check for stop signals
            if (stepContext.getStepExecution().getStatus().isUnsuccessful()
                || stepContext.getStepExecution().getJobExecution().getStatus().isUnsuccessful()) {
              log.info(
                  "Job {} has been stopped during progress update, exiting tile processing", jobId);
              return;
            }
          }
        }
      }
      bounds = calculateBounds(service, capabilities.getLayers());
      MetadataBounds metBounds = new MetadataBounds(bounds[0], bounds[1], bounds[2], bounds[3]);
      writer.addMetadataEntry(
          new MetadataEntry(
              service.getLayers().get(0),
              MetadataEntry.TileSetType.BASE_LAYER,
              "1.0",
              "Layer generated by Sitmun mbtiles",
              MetadataEntry.TileMimeType.PNG,
              metBounds));
      writer.close();
    } catch (Exception e) {
      throw new WMTSHarvestException(e);
    }
  }

  private void addOrUpdateTitle(
      TileCoordinate coord,
      CustomMBTilesReader reader,
      BufferedImage tile,
      CustomMBTilesWriter writer)
      throws IOException, MBTilesWriteException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    int zoom = coord.getZ();
    int yTMS = invertTileRow(coord.getY(), zoom);
    BufferedImage saveTile = checkTileImage(reader, zoom, coord.getX(), yTMS);
    if (saveTile == null) {
      ImageIO.write(tile, "png", baos);
      writer.addTile(baos.toByteArray(), zoom, coord.getX(), yTMS);
    } else {
      BufferedImage combinedTile = writer.combineTiles(saveTile, tile);
      ImageIO.write(combinedTile, "png", baos);
      writer.updateTile(zoom, coord.getX(), yTMS, baos.toByteArray());
    }
  }

  private BufferedImage getTileImage(
      TileServiceDto service, String layer, TileCoordinate coordinate) {
    byte[] tileData =
        WMTSUtils.downloadTile(
            service.getUrl(),
            layer,
            service.getMatrixSet(),
            coordinate.getX(),
            coordinate.getY(),
            coordinate.getZId());

    if (tileData != null) {
      try {
        return ImageIO.read(new ByteArrayInputStream(tileData));
      } catch (IOException e) {
        log.error("Error decoding image", e);
      }
    }
    return null;
  }

  private double[] calculateBounds(TileServiceDto service, List<LayerCapabilities> layers) {
    double[] bounds = {
      service.getMinLon(), service.getMinLat(), service.getMaxLon(), service.getMaxLat()
    };
    for (LayerCapabilities lc : layers) {
      if (lc.getMinLon() != null && lc.getMinLon() < bounds[0]) {
        bounds[0] = lc.getMinLon();
      }
      if (lc.getMinLat() != null && lc.getMinLat() < bounds[1]) {
        bounds[1] = lc.getMinLat();
      }
      if (lc.getMaxLon() != null && lc.getMaxLon() > bounds[2]) {
        bounds[2] = lc.getMaxLon();
      }
      if (lc.getMaxLat() != null && lc.getMaxLat() > bounds[3]) {
        bounds[3] = lc.getMaxLat();
      }
    }
    return bounds;
  }

  private int invertTileRow(int tileRow, int zoom) {
    return ((1 << zoom) - 1 - tileRow);
  }

  private BufferedImage checkTileImage(CustomMBTilesReader reader, int z, int x, int y) {
    try {
      Tile tile = reader.getTile(z, x, y);
      if (tile != null && tile.getData() != null) {
        ByteArrayInputStream bais = new ByteArrayInputStream(tile.getData().readAllBytes());
        return ImageIO.read(bais);
      }
      return null;
    } catch (Exception e) {
      log.error("Error reading tile Z: {}, X: {}, Y: {} - {}", z, x, y, e.getMessage());
      return null;
    }
  }
}
